// ProfStudioProperties.cpp : implementation file
//

#include "stdafx.h"

#include "..\MainFrm.h"
#include "PropertiesBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProfStudioPropertyGridCtrl window

CProfStudioPropertyGridCtrl::CProfStudioPropertyGridCtrl()
	: m_PS( _T("Properties") ),
	  pCurView(NULL)
{
//

}

CProfStudioPropertyGridCtrl::~CProfStudioPropertyGridCtrl()
{
	Reset();
}

void CProfStudioPropertyGridCtrl::Reset()
{
	// Free any of the property value managers left
	map<CExtPropertyItem*, CPropValueMgr*>::iterator i;

	for (i = propValueMgrs.begin(); i != propValueMgrs.end(); i++) {
		delete i->second;
	}

	propValueMgrs.clear();
}

void CProfStudioPropertyGridCtrl::OnPgcInputComplete(CExtPropertyGridWnd * pPGW, CExtPropertyItem * pPropertyItem)
{
	CExtPropertyGridCtrl::OnPgcInputComplete(pPGW, pPropertyItem);

	DoItemChange(pPropertyItem);
}

// Call the OnChange for a property when it changed.
void CProfStudioPropertyGridCtrl::DoItemChange(CExtPropertyItem* pItem)
{
	// Call the property value manager for this item
	int ret;

	// Item not found?
	if (propValueMgrs.find(pItem) == propValueMgrs.end()) {
		
		// The item is a mixed item, generated by combining property grids for multiple selections.
		// Call OnChange for all its children, to affect all.

		for (int i = 0; i < pItem->ItemGetCount(); i++)
			ret = propValueMgrs[pItem->ItemGetAt(i)]->OnChange();
	}
	else
		ret = propValueMgrs[pItem]->OnChange();

	// Something was changed: application now modified
	if (pCurView != NULL && pCurView->application != NULL)
		pCurView->application->ChangeModifiedStatus();

	switch (ret) {
	case 1:	// Refresh property bar if a property added
		if (pPropBar)
			pPropBar->Refresh();
		break;
	case 2: // Refresh frame if a frame property changed
		if (pCurView)
		{
			pCurView->Invalidate();
			pCurView->m_UpdatePreview = true;
		}
		break;
	case 4:	// Refresh property AND frame
		if (pPropBar)
			pPropBar->Refresh();
		if (pCurView)
			pCurView->Invalidate();
		break;
	case 5: // Refresh animator bar
		if (g_MainFrame)
			g_MainFrame->animator.UpdateAnimations(NULL, NULL, NULL, -2);
		break;
	case 6:	// Refresh layer bar
		if (g_MainFrame) {
			g_MainFrame->m_LayerBar.m_layerDlg.RefreshLayers();
		}
	}


	// Unfocus grid to prevent spurious item edits after updating
	::SetFocus(NULL);
}

// Instantiate a window with overriden ItemExpand
bool CProfStudioPropertyGridCtrl::OnPgcCreateGrids()
{
	ASSERT_VALID( this );
    try
    {
        pGridCategorized =
            new CExtPropertyGridWndCategorizedEx( this );
        pGridCategorized->m_bAutoDeleteWindow = true;
        if( ! pGridCategorized->Create(
                this,
                __EXT_MFC_ID_PROPERTY_GRID_CATEGORIZED,
                true
                )
            )
        {
            ASSERT( FALSE );
            throw __EXT_MFC_ID_PROPERTY_GRID_CATEGORIZED;
        }

		pGridCategorized->m_bSortedCategories = false;

        CExtPropertyGridWndSorted * pGridSorted =
            new CExtPropertyGridWndSorted( this );
        pGridSorted->m_bAutoDeleteWindow = true;
        if( ! pGridSorted->Create(
                this,
                __EXT_MFC_ID_PROPERTY_GRID_SORTED
                )
            )
        {
            ASSERT( FALSE );
            throw __EXT_MFC_ID_PROPERTY_GRID_SORTED;
        }
    }
    catch( ... )
    {
        return false;
    }
    return true;
}


/*
void CExtPropertyGridWndCategorizedEx::ItemExpand(HTREEITEM hTreeItem, INT nActionTVE, bool bRedraw)
{
	CString msg;
	msg.Format("Item expanding: %d", nActionTVE);
	MessageBox(msg);

	CExtPropertyGridWndCategorized::ItemExpand(hTreeItem, nActionTVE, bRedraw);
}
*/

LRESULT CProfStudioPropertyGridCtrl::WindowProc( UINT message, WPARAM wParam, LPARAM lParam)
{
LRESULT lResult =
		CExtPropertyGridCtrl::WindowProc( message, wParam, lParam );
	if( message == WM_CREATE )
	{
		PropertyStoreSet( &m_PS );
		CTypedPtrArray < CPtrArray, CExtPropertyGridWnd * > arrGrids;
		OnPgcQueryGrids( arrGrids );
		INT nGridIdx = 0;
		for( ; nGridIdx < arrGrids.GetSize(); nGridIdx ++ )
		{
			CExtPropertyGridWnd * pGrid = arrGrids[ nGridIdx ];
			ASSERT_VALID( pGrid );
			g_PaintManager->LoadWinXpTreeBox(
				pGrid->m_iconTreeBoxExpanded,
				true
				);
			g_PaintManager->LoadWinXpTreeBox(
				pGrid->m_iconTreeBoxCollapsed,
				false
				);
		} // for( ; nGridIdx < arrGrids.GetSize(); nGridIdx ++ )
		CExtPropertyGridComboBoxBar * pCBB =
			STATIC_DOWNCAST(
				CExtPropertyGridComboBoxBar,
				GetChildByRTC(
					RUNTIME_CLASS(CExtPropertyGridComboBoxBar)
					)
				);
		pCBB->PropertyStoreInsert( &m_PS );
	} // if( message == WM_CREATE )
	return lResult;
}

void CExtGridCellCurrencyEx::TextGet( CExtSafeString & strCopy ) const
{
    ASSERT_VALID( this );
    if(        (GetStyleEx()&__EGCS_EX_UNDEFINED_ROLE) != 0 
        ||    IsEmpty()
        )
    {
        strCopy = _T("");
        return;
    }
    strCopy.Empty();

VARIANT varCopy;
    ::VariantInit( &varCopy );
HRESULT hr = 
        ::VariantCopy( 
            &varCopy, 
            LPVARIANT( LPCVARIANT( this ) )
            );
    if(        FAILED(hr)
        ||    (!OnTextGetPrepareVariant( &varCopy ))
        )
    {
        ASSERT( FALSE );
        return;
    }

CExtSafeString sNumberText;
bool bRet = OnQueryNumberText( &varCopy, sNumberText );
    
    ::VariantClear( &varCopy );
    
    if( !bRet )
        return;

UINT nNumDigits = OnQueryNumDigits();
//    if( ! OnQueryTrailingZeroes() )
    {
        INT nPosPoint = sNumberText.ReverseFind( _T('.') );
        UINT nNumDigitsReal = 0;
        if( nPosPoint >= 0 )
            nNumDigitsReal = min( sNumberText.GetLength() - 1 - nPosPoint, 9 );
        if( nNumDigitsReal < nNumDigits )
            nNumDigits = nNumDigitsReal;
    }

CURRENCYFMT fmt;
    memset( &fmt, 0, sizeof(CURRENCYFMT) );

    fmt.NumDigits = nNumDigits;
    fmt.LeadingZero = OnQueryLeadingZero();
    fmt.NegativeOrder = OnQueryNegativeOrder();
    fmt.PositiveOrder = OnQueryPositiveOrder();

CExtSafeString sGrouping;
    OnQueryGrouping( sGrouping );
    sGrouping.Remove( _T(';') );
    sGrouping.TrimRight( _T('0') );
    fmt.Grouping = _ttoi( sGrouping );
    
CExtSafeString sDecimalSep;
    OnQueryDecimalSeparator( sDecimalSep );
    fmt.lpDecimalSep = sDecimalSep.GetBuffer( sDecimalSep.GetLength() );
    sDecimalSep.ReleaseBuffer();
    
CExtSafeString sThousandSep;
    OnQueryThousandSeparator( sThousandSep );
    fmt.lpThousandSep = sThousandSep.GetBuffer( sThousandSep.GetLength() );
    sThousandSep.ReleaseBuffer();
    
CExtSafeString sCurrencySymbol;
    OnQueryCurrencySymbol( sCurrencySymbol );
    fmt.lpCurrencySymbol = sCurrencySymbol.GetBuffer( sCurrencySymbol.GetLength() );
    sCurrencySymbol.ReleaseBuffer();

    VERIFY(
        g_ResourceManager->GetCurrencyFormat(
              0,
              sNumberText,
              &fmt,
              strCopy.GetBuffer( 100 ),
              100
            ) != 0
        );
    strCopy.ReleaseBuffer();
}

void CExtGridCellNumberEx::TextGet( CExtSafeString & strCopy ) const
{
	ASSERT_VALID( this );
	if(		(GetStyleEx()&__EGCS_EX_UNDEFINED_ROLE) != 0 
		||	IsEmpty()
		)
	{
		strCopy = _T("");
		return;
	}
	strCopy.Empty();

VARIANT varCopy;
	::VariantInit( &varCopy );
HRESULT hr = 
		::VariantCopy( 
			&varCopy, 
			LPVARIANT( LPCVARIANT( this ) )
			);
	if(		FAILED(hr)
		||	(!OnTextGetPrepareVariant( &varCopy ))
		)
	{
		ASSERT( FALSE );
		return;
	}

CExtSafeString sNumberText;
bool bRet = OnQueryNumberText( &varCopy, sNumberText );
	
	::VariantClear( &varCopy );
	
	if( !bRet )
		return;

	UINT nNumDigits = OnQueryNumDigits();
//    if( ! OnQueryTrailingZeroes() )
    {
        INT nPosPoint = sNumberText.ReverseFind( _T('.') );
        UINT nNumDigitsReal = 0;
        if( nPosPoint >= 0 )
            nNumDigitsReal = min( sNumberText.GetLength() - 1 - nPosPoint, 9 );
        if( nNumDigitsReal < nNumDigits )
            nNumDigits = nNumDigitsReal;
    }


NUMBERFMT fmt;
	memset( &fmt, 0, sizeof(NUMBERFMT) );

	fmt.NumDigits = nNumDigits;
	fmt.LeadingZero = OnQueryLeadingZero();
	fmt.NegativeOrder = OnQueryNegativeOrder();

CExtSafeString sGrouping;
	OnQueryGrouping( sGrouping );
	sGrouping.Remove( _T(';') );
	sGrouping.TrimRight( _T('0') );
	fmt.Grouping = _ttoi( sGrouping );
	
CExtSafeString sDecimalSep;
	OnQueryDecimalSeparator( sDecimalSep );
	fmt.lpDecimalSep = sDecimalSep.GetBuffer( sDecimalSep.GetLength() );
	sDecimalSep.ReleaseBuffer();
	
CExtSafeString sThousandSep;
	OnQueryThousandSeparator( sThousandSep );
	fmt.lpThousandSep = sThousandSep.GetBuffer( sThousandSep.GetLength() );
	sThousandSep.ReleaseBuffer();

	VERIFY(
		g_ResourceManager->GetNumberFormat(
			  0,
			  sNumberText,
			  &fmt,
			  strCopy.GetBuffer( 100 ),
			  100
			) != 0
		);
	strCopy.ReleaseBuffer();
}